<conversation_summary> <decisions> 1. Persist complete Pokémon catalog via normalized `sets`, `cards`, and `rarities` tables synced from APIs. 2. Track pricing in a dedicated `card_prices` table with `(card_id, price_source)` uniqueness and currency metadata. 3. Model user ownership through a `collection_entries` table (surrogate PK) storing `user_id`, `card_id`, `condition_code`, `quantity` with quantity > 0 constraint. 4. Standardize condition values through a `card_conditions` lookup (preferred) or ENUM enforced via FK from `collection_entries`. 5. Expose collection summaries using SQL views/materialized views (`collection_set_summary`, `collection_value_view`) instead of duplicating data. 6. Implement API caching inside an `api_cache` table (`endpoint_key`, `payload`, `fetched_at`, `expires_at`) with targeted indexing for eviction. 7. Enable RLS on every user-scoped table using JWT-driven `auth.uid()` checks with distinct read/write policies. 8. Add targeted indexes: composite `cards(set_id, card_number)`, text search index for card names, and `collection_entries` indexes on `(user_id, card_id)` and `(user_id, set_id)`. 9. Add `tcg_type` columns to core tables to ease future cross-TCG expansion without immediate partitioning. 10. Reference Supabase `auth.users` for `user_id` with `ON DELETE CASCADE` to avoid orphaned rows. 11. Confirm JWT-based auth enforcement for RLS (policies rely on `auth.uid()`). <matched_recommendations> 1. Catalog persistence recommendation matches decision 1. 2. Pricing table recommendation matches decision 2. 3. Collection modeling recommendation matches decision 3. 4. Condition lookup recommendation matches decision 4. 5. Views/materialized views recommendation matches decision 5. 6. API cache table recommendation matches decision 6. 7. RLS enforcement recommendation matches decision 7 and the JWT clarification. 8. Indexing strategy recommendation matches decision 8. 9. Future partition-readiness recommendation matches decision 9. 10. `auth.users` FK cascade recommendation matches decision 10. <database_planning_summary> The MVP database must store both static Pokémon catalog data and user-specific ownership data. Core schema elements include `sets`, `cards`, `rarities`, `card_prices`, `card_conditions`, and `collection_entries`, supplemented by derived views for set summaries and total valuations. `collection_entries` links users to cards, accepts multiple entries per card, and enforces positive quantities and valid condition codes. Card pricing data is normalized to allow multiple sources per card with timestamped refreshes. API responses are cached in PostgreSQL with TTL metadata to satisfy the 24-hour reuse requirement.

Security hinges on Supabase’s JWT-backed RLS; every user-facing table requires user_id FKs to auth.users plus policies that check user_id = auth.uid() for both reads and writes. Cascading deletes ensure cleanup when accounts are removed. Indexing is planned for catalog lookup (set+number sorting, full-text card names) and user collections (user-based filters). Scalability considerations include designing tables with a tcg_type column to accommodate future multi-franchise data and deferring heavy partitioning until needed, while materialized views keep profile metrics performant without duplicating row data.

<unresolved_issues> - None identified; current plan covers schema, RLS, caching, and indexing requirements. </unresolved_issues> </conversation_summary>
